/* eslint-disable @typescript-eslint/no-explicit-any */
import { Project } from 'ts-morph'

function collectExportedSourceFiles(sf: any, acc = new Set<any>()) {
  for (const exp of sf.getExportDeclarations()) {
    const ref = exp.getModuleSpecifierSourceFile()
    if (ref && !acc.has(ref)) {
      acc.add(ref)
      collectExportedSourceFiles(ref, acc)
    }
  }
  return acc
}

type ServiceInfo = {
  serviceName: string
  actions: ActionInfo[]
  events: EventInfo[]
}

type ActionInfo = {
  method: string
  channel: string
  paramType: string
  returnType: string
}

type EventInfo = {
  method: string
  channel: string
  paramType: string
}

function resolveServiceName(cls: any): string {
  const deco = cls.getDecorator('Service')
  if (!deco) return ''

  const args = deco.getArguments()
  if (args.length > 0) {
    return args[0].getText().replace(/['"]/g, '')
  }

  return cls.getName().replace('Service', '').toLowerCase()
}

function parseAction(method: any): ActionInfo | null {
  const deco = method.getDecorator('Action')
  if (!deco) return null

  const channel = deco.getArguments()[0].getText().replace(/['"]/g, '')

  return {
    method: method.getName(),
    channel,
    paramType: method.getParameters()[0]?.getType().getText(),
    returnType: method.getReturnType().getText(),
  }
}

function parseEvent(method: any): EventInfo | null {
  const deco = method.getDecorator('Event')
  if (!deco) return null

  const channel = deco.getArguments()[0].getText().replace(/['"]/g, '')

  return {
    method: method.getName(),
    channel,
    paramType: method.getParameters()[0]?.getType().getText(),
  }
}

function generatePreload(services: ServiceInfo[]) {
  const out: string[] = []

  out.push(`// This file is generated by generate-preload.ts`)
  out.push(`import { contextBridge, ipcRenderer } from 'electron'\n`)
  out.push(`const api = {`)

  for (const s of services) {
    out.push(`  ${s.serviceName}: {`)

    for (const a of s.actions) {
      const argName = a.paramType?.includes('{') ? 'payload' : 'id'
      out.push(
        `    ${a.method}: (${argName}: ${a.paramType}) => ` +
        `ipcRenderer.invoke('${a.channel}', ${argName}),`,
      )
    }

    for (const e of s.events) {
      out.push(
        `    ${e.method}: (msg: ${e.paramType}) => ` + `ipcRenderer.send('${e.channel}', msg),`,
      )
    }

    out.push(`  },`)
  }

  out.push(`}`)
  out.push(`\n`)
  out.push(`contextBridge.exposeInMainWorld('NATIVE_API', api)`)
  out.push(`\n`)
  out.push(`export type ApiType = typeof api`)

  return out.join('\n')
}
//============================ BEGIN OF SECTION ==============================//
console.log('Generating preload...')

const project = new Project({
  tsConfigFilePath: 'tsconfig.node.json',
})
const entry = project.getSourceFileOrThrow('electron/main/services/index.ts')
const serviceFiles = collectExportedSourceFiles(entry)

const services: ServiceInfo[] = []

for (const sf of serviceFiles) {
  for (const cls of sf.getClasses()) {
    if (!cls.getDecorator('Service')) continue

    const service: ServiceInfo = {
      serviceName: resolveServiceName(cls),
      actions: [],
      events: [],
    }

    for (const method of cls.getMethods()) {
      const action = parseAction(method)
      if (action) service.actions.push(action)

      const event = parseEvent(method)
      if (event) service.events.push(event)
    }

    services.push(service)
  }
}

const outs = generatePreload(services)
project.createSourceFile('electron/preload/index.ts', outs, { overwrite: true }).saveSync()
console.log('Preload generated.')
//============================ END OF SECTION ==============================//
